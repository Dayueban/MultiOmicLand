#' rf_MetaG.MetaB.HostTLinks function
#'
#' This function allows you to evaluate the accuracy of predicting e.g. a clinical variable by the MetaG.MetaB.HostT links through random forest modeling.  
#' Dependent packages includes "tidymodels", "tidyverse","workflows ,"tune", "ranger" and "data.table".
#' This function generates a performance table recording prediction performance of each MetaG.MetaB.HostT link, as rsme and rsq for "regression", 
#' and as accuracy and roc_auc for "classification". 
#' 
#' @param  MetaG.Mod.input   the gct file generated by ssGSEA2 or a data frame with rownames being the modules and colnames being the samples
#' @param  MetaB.Mod.input   the txt file generated by wgcna or a data frame with rownames being the modules and colnames being the samples
#' @param  HostT.Mod.input   the txt file generated by wgcna or a data frame with rownames being the modules and colnames being the samples
#' @param  MetaG.MetaB.HostT.link.df   a data frame with columns named "MetaG", "MetaB, and "HostT" 
#' @param  PredictedVar.input  a data frame with one column named "SampleID" and another column giving the predicted variable (should be factor if the prediction is classification)
#' @param  PredictionType    the type of prediction, "regression" or "classification". 
#' @param  Training.samples  samples used as training set. If defined, all other samples will be used for validation. If not defined, the total samples will be randomly split into training set (3/4) and validation set (1/4) 
#' 
#' @examples
#' rf_MetaG.MetaB.HostTLinks(MetaG.Mod.input = "metaG_DR/metaG-combined.gct", 
#'                           MetaB.Mod.input =  MetaB.Mod.dat, 
#'                           HostT.Mod.input =  HostT.Mod.dat,
#'                           MetaG.MetaB.HostT.link.df = MetaG.MetaB.HostT.links,
#'                           PredictedVar.input = meta,
#'                           PredictionType =  "regression")
#'                  


rf_MetaG.MetaB.HostT.Links <- function(
  
  MetaG.Mod.input = "metaG_DR/metaG-combined.gct",
  MetaB.Mod.input = MetaB.Mod.dat,  
  HostT.Mod.input = HostT.Mod.dat,  
  MetaG.MetaB.HostT.link.df = MetaG.MetaB.HostT.links,  
  PredictedVar.input = meta,   
  PredictionType = "regression",  
  Training.samples = NULL,
  log.file = "rf_by.links.log",
  output.dir = "rf_performance",
  output.prefix = ""
){
  
  library("tidymodels")
  library(tidyverse)
  library("workflows")
  library("tune")
  library(ranger)
  
  library(data.table)
  #library(ggplot2)
  
  ## ############################################################################
  ##                                                                           ## 
  ##                 Import data                                               ## 
  ##                                                                           ## 
  ## ############################################################################
  
  cat(paste("\n\n",as.character(Sys.time()), '\n'),  file=log.file, append=T)
  cat("Importing data : \n", file=log.file, append=T)
  
  
  # metagenomic data ------
  if(class(MetaG.Mod.input) == "character"){
    
    if(grepl("\\.gct$", MetaG.Mod.input)) m1 <- parse.gctx(MetaG.Mod.input)@mat %>% t() %>% data.frame() else m1 <- data.frame(fread(MetaG.Mod.input), row.names=1)
    
  }else{
    
    m1 = MetaG.Mod.input
    feature.abb_df1 <- cbind.data.frame(feature = rownames(m1),
                                        abb = paste("feature",seq(1,nrow(m1),1),sep = ""),
                                        stringsAsFactors = F)
    rownames(m1) <- sapply(rownames(m1), function(x) feature.abb_df1$abb[which(feature.abb_df1$feature == x)])
    m1 <- t(m1) %>% as.data.frame(stringsAsFactors=F)
    colnames(m1) <- sapply(colnames(m1), function(x) feature.abb_df1$feature[which(feature.abb_df1$abb == x)])
    
  }
  #colnames(m1) <- paste("MetaG.", colnames(m1),sep = "")
  
  # metabolomic data -----
  if(class(MetaB.Mod.input) == "character"){
    
    if(grepl("\\.gct$", MetaB.Mod.input)) m2 <- parse.gctx(MetaB.Mod.input)@mat %>% t() %>% data.frame() else m2 <- data.frame(fread(MetaB.Mod.input), row.names=1)
    
  }else{
    
    m2 = MetaB.Mod.input
    feature.abb_df1 <- cbind.data.frame(feature = rownames(m2),
                                        abb = paste("feature",seq(1,nrow(m2),1),sep = ""),
                                        stringsAsFactors = F)
    rownames(m2) <- sapply(rownames(m2), function(x) feature.abb_df1$abb[which(feature.abb_df1$feature == x)])
    m2 <- t(m2) %>% as.data.frame(stringsAsFactors=F)
    colnames(m2) <- sapply(colnames(m2), function(x) feature.abb_df1$feature[which(feature.abb_df1$abb == x)])
    
  }
  #colnames(m2) <- paste("MetaB.", colnames(m2),sep = "")
  
  
  # host transcriptomic data -----
  if(class(HostT.Mod.input) == "character"){
    
    if(grepl("\\.gct$", HostT.Mod.input)) m3 <- parse.gctx(HostT.Mod.input)@mat %>% t() %>% data.frame() else m3 <- data.frame(fread(HostT.Mod.input), row.names=1)
    
  }else{
    
    m3 = HostT.Mod.input
    feature.abb_df1 <- cbind.data.frame(feature = rownames(m3),
                                        abb = paste("feature",seq(1,nrow(m3),1),sep = ""),
                                        stringsAsFactors = F)
    rownames(m3) <- sapply(rownames(m3), function(x) feature.abb_df1$abb[which(feature.abb_df1$feature == x)])
    m3 <- t(m3) %>% as.data.frame(stringsAsFactors=F)
    colnames(m3) <- sapply(colnames(m3), function(x) feature.abb_df1$feature[which(feature.abb_df1$abb == x)])
    
  }
  #colnames(m3) <- paste("HostT.", colnames(m3),sep = "")
  
  
  # clinical variable of interest -------
  if(F){
    if(class(PredictedVar.input) =="character"){
      Predicted.dat <- fread(PredictedVar.input, data.table = F)
    }else{
      Predicted.dat <- PredictedVar.input
    }
  }
  
  Predicted.dat <- PredictedVar.input
  Y = colnames(Predicted.dat)[colnames(Predicted.dat) != "SampleID"] 
  colnames(Predicted.dat)[which(colnames(Predicted.dat) == Y)] <- "Y"
  head(Predicted.dat)
  
  # match rows of all the data frames ------
  completeSps <- intersect(intersect(intersect(rownames(m1), rownames(m2)), rownames(m3)), Predicted.dat$SampleID)
  m1 <- m1[match(completeSps, rownames(m1)),]
  m2 <- m2[match(completeSps, rownames(m2)),]
  m3 <- m3[match(completeSps, rownames(m3)),]
  Predicted.dat <- Predicted.dat[match(completeSps, Predicted.dat$SampleID),]
  
  
  
  # MetaG.MetaB.HostT.link -------
  link.df <- MetaG.MetaB.HostT.link.df
  
  
  ## ############################################################################
  ##                                                                           ## 
  ##         integrate data for random forest                                  ## 
  ##                                                                           ## 
  ## ############################################################################
  
  cat("Performing random forest modeling : \n", file=log.file, append=T)
  
  
  Performance <- NULL
  for(i in c(1:nrow(link.df))){ # nrow(link.df)
    # i=1
    
    if(i %% 100 == 0) cat(paste("----progress: predicting ", Y, "with link ", i ," out of the total ", nrow(link.df), " links ----------", sep = "") , file=log.file, append=T )
      
    Gm <- sub("MetaG\\.","", link.df$MetaG[i])
    Bm <- sub("MetaB\\.","",link.df$MetaB[i])
    Tm <- sub("HostT\\.", "", link.df$HostT[i])
    
    rf_dat <- cbind.data.frame(SampleID = rownames(m1), 
                               MetaG = m1[,Gm], 
                               MetaB = m2[,Bm],
                               HostT = m3[,Tm],
                               Y = Predicted.dat[,"Y"],
                               stringsAsFactors=F)
    
    rf_dat <- rf_dat[complete.cases(rf_dat),]
    
    # split the data into traing and testing sets 
    set.seed(100)
    if( is.null(Training.samples) ){
      rf_dat <- rf_dat[,-which(colnames(rf_dat) == "SampleID")]
      my_split <- initial_split(rf_dat,  prop = 3/4, strata = Y) 
      my_train <- training(my_split)
      my_test <- testing(my_split)
    }else {
      tmp.ids <- unlist(sapply(Training.samples, function(x) which(rf_dat$SampleID == x))) 
      
      rf_dat <- rf_dat[,-which(colnames(rf_dat) == "SampleID")]
      
      my_split <- initial_split(rf_dat) 
      my_split$in_id <- unname(tmp.ids)  # manually adjust training sample ids 
      my_train <- training(my_split)
      my_test <- testing(my_split)
      
    }
    
    
    # create a cross validation version of the training set for parameter tuning
    my_cv <- vfold_cv(my_train, strata = Y, v =5)
    
    # define the recipe
    my_recipe <- 
      # which consists of the formula (outcome ~ predictors)
      recipe(Y ~ ., data = rf_dat)  # %>%
    #step_knnimpute(all_predictors()) # missing value
    
    
    # Specify the model --------------------------------------
    rf_model <- 
      # specify that the model is a random forest
      rand_forest() %>%  # ?rand_forest shows the tunable parameters
      # specify that the `mtry` parameter needs to be tuned
      set_args(mtry = tune(), trees=tune(),min_n=10) %>%
      # select the engine/package that underlies the model
      set_engine("ranger", importance = "impurity") %>% # if to examine the variable importance of your final model need to set importance = 
      # choose either the continuous regression or binary classification mode
      set_mode(PredictionType) 
    
    
    
    #  Put it all together in a workflow -----------------------------------
    # set the workflow
    rf_workflow <- workflow() %>%
      # add the recipe
      add_recipe(my_recipe) %>%
      # add the model
      add_model(rf_model) 
    
    
    # Tune the parameters ----------------------------------
    # specify which values eant to try
    rf_grid <- expand.grid(mtry = c(1,2,3), trees=c(500,1000)) 
    # extract results
    if(PredictionType == "regression"){
      rf_tune_results <- rf_workflow %>%
        tune_grid(resamples = my_cv, #CV object
                  grid = rf_grid, # grid of values to try
                  metrics = metric_set(rmse) # metrics we care about
        )
      resultSelect = "rmse"
    }else{
      rf_tune_results <- rf_workflow %>%
        tune_grid(resamples = my_cv, #CV object
                  grid = rf_grid, # grid of values to try
                  metrics = metric_set(accuracy, roc_auc) # metrics we care about
        )
      resultSelect = "accuracy"
    }
    
    # autoplot(rf_tune_results)
    
    # print results
    results_df <- rf_tune_results %>%
      collect_metrics()
    
    # Finalize the workflow ------------------------------------------
    
    param_final <- rf_tune_results %>%
      select_best(metric = resultSelect) # 采用最高accuracy的参数
    param_final
    
    rf_workflow <- rf_workflow %>%
      finalize_workflow(param_final) 
    
    
    
    
    
    # Evaluate the model on the test set --------------------------------
    rf_fit <- rf_workflow %>%
      # fit on the training set and evaluate on test set
      last_fit(my_split) # train the training dataset and evaluate the test dataset
    
    
    
    # check performance
    performance <- rf_fit %>% collect_metrics()
    performance  
    
    performance$MetaG.MetaB.HostT.link = paste(Gm, Bm, Tm, sep = "_")
    
    Performance <- bind_rows(Performance, performance)
    
  }
  
  if(!dir.exists(output.dir)) dir.create(output.dir)
  write.table(Performance, file = paste(output.dir,"/",output.prefix,"predictio.performance_byLinks.rf.txt",sep = ""), sep = "\t", quote = F, row.names = F)
  
  
  return(Performance)
  
  
  
}